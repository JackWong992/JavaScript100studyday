# 3-函数的运行机制
> 在JavaScript就是一个方法(一个功能体),基于函数一般就是为了实现某个功能。
```javascript
  var total = 10 ;
  total+=10;
  total = total/2;
  total = total.toFixed(2) //保留小数点后面的位数
```
在后面的代码中，我们依然想实现相同的操作(加10除以2)，我们需要重新编写代码:
```javascript
  total+=10;
  total = total/2;
  total = total.toFixed(2)
```
我们这样的方式导致页面中存在大量冗余的代码，也降低了开发的效率，如果我们能把实现这个功能的代码实现『封装』,后面我们需要这个功能执行即可，这样就更好了.
```javascript
  functio total(val){
    val+=10;
    val/=2;
    val = val.toFixed(2)
  }
```
`函数诞生的目的就是为了实现封装:`把实现一个功能的代码封装到一个函数中，后期想要实现这个功能，只需要执行这个函数即可，不必要再次编写重复的代码.起到了**低耦合高内聚**(减少页面中的冗余代码，提高了代码的重复使用率)的作用,想用多少次，我们只需要执行多少次函数就行.

---
ES3标准中:<br>

=>创建函数
```javascript
  function 函数名([参数]){
    函数体: 实现功能的JavaScript代码
  }
```
=>函数执行<br>
函数名()


ES6标准中 <br>

=>创建函数
```javascript
  let 函数名(变量名) = ([参数])=>{
    函数体
  }
  函数名();
```

箭头函数：
```javascript
  let 函数名=()=>{
    函数体
  }
  函数名();
```
函数作为引用数据类型中的一种，它也是按照引用地址来操作的，我们根据这个引用地址了解函数的运行机制
```javascript
  var obj = {
    name: 'w',
  }
```
1. 函数也是引用类型，首先会开辟一个新的堆内存，把函数体中的代码当做『字符串』存储到内存中,(对象向内存中存储的是键值对)
2. 把开辟的堆内存地址赋值给函数名(变量名)

`fn`是函数本身<br>
`fn()`是调用函数,执行函数

[函数执行]

目的：把之前存储到堆内存中的代码字符串变为真正的JavaScript代码自上而下的执行，从而实现应有的功能

1. 函数执行：首先会形成一个私有作用域(一个供代码执行的环境，也就是一个内存)
2. 把之前在堆内存中存储的字符串复制一份过来，变为真正的JavaScript代码，在新开辟的作用域中自上而下的执行.

> 每次函数的执行一次就会新开辟一个新的内存地址.每次执行的私有作用域都是不相同的

JS三座大山：异步编程，闭包，堆栈内存释放


### 区别
> 对于对象来说在堆内存中存储的都是有意义的键值对，而对于函数来说存储的都是无意义的代码字符串

[![1061558759536_.pic.jpg](https://i.loli.net/2019/05/25/5ce8c89092af279803.jpg)](https://i.loli.net/2019/05/25/5ce8c89092af279803.jpg)
